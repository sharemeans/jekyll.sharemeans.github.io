##异步，Promise，generator,async

###javascript线程

 1.javascript本身是单线程，也是主线程
 
 2.js主线程有一个任务队列（event loop）
 
 3.浏览器不是单线程
 >GUI线程(负责页面渲染，不过大多数属于主线程)
 >ajax请求线程
 >
 >浏览器事件触发线程（click），时间触发的时候也会把任务推进主线程的任务队列中，等待主线程执行
 >
 >浏览器定时器线程，setTimeout在计时结束之后把任务推进任务队列中(问个问题，setTimeout准不准？为什么有写动画会卡顿-任务丢失)) 
 
 4.GUI线程和js主线程同一个时间只能有一个在执行，
 
 5.js主线程的代码执行完之后才执行任务队列的代码
 
	var isEnd = false;
	setTimeout(function(){
		isEnd = true;
		console.log('isEnd: ', isEnd)
	},0)
	for(var i = 0; i < 10000; i++){
		console.log('isEnd: ', isEnd)
	}
	console.log('end')
	
个人理解：javascript单线程，但是事件触发机制形成了异步的假象


###同步&异步

同步代码会按照顺序执行，前面的代码没有执行完毕的话，后面的代码就不会执行。
异步的代码（ajax和event的回调）在等待返回的时候可以继续执行下面的代码。

很多时候我们需要等数据返回之后才能决定要做什么，可能返回数据之后还要继续ajax请求。。。

	
###古老的异步编程模式
1.回调

2.发布/订阅

3.promise


####回调地狱

	                                        });
	                                    });
	                                });
	                            });
	                        });
	                    });
	                });
	            });
	        });
	    });
	});

###promise

####使用串行的风格解决异步回调问题
	somePromise().then(functoin(){
        // do something
    })
    .then(function(){
    	 // do something
    })
    .then(function(){
    	 // do something
    })
####更灵活处理错误

	somePromise.then(function() {
	 return a.b.c.d();
	}).catch(TypeError, function(e) {
	 //If a is defined, will end up here because
	 //it is a type error to reference property of undefined
	}).catch(ReferenceError, function(e) {
	 //Will end up here if a wasn't defined at all
	}).catch(function(e) {
	 //Generic catch-the rest, error wasn't TypeError nor
	 //ReferenceError
	});
	
三种状态：

- pending 等待中，还没有得到结果
- resolved(fulfilled) 得到了想要的结果，可以继续执行
- rejected 得到并非所愿的结果，拒绝继续执行

		function fn(num) {
		   return new Promise(function(resolve, reject) {
		       if (typeof num == 'number') {
		           resolve();
		       } else {
		           reject();
		       }
		   }).then(function() {
		       console.log('resolve执行之后的回调');
		   }, function() {
		       console.log('reject执行之后的回调');
		   })
		}

特点：

- 异步操作的状态由执行结果决定
- 状态可以保持，即使状态在resolved和reject的情况下，也能添加回调且立即执行。
	
	
简易版的promise实现：

	function Promise(fn) {
	    var state = 'pending',
	        value = null,
	        deferreds = [];
	
	    this.then = function (onFulfilled) {
	    	// 如果状态为起始状态，则添加到任务队列
	        if (state === 'pending') {
	            deferreds.push(onFulfilled);
	            return this;
	        }
	        // 否则立即执行
	        onFulfilled(value);
	        return this;
	    };
	
	    function resolve(newValue) {
	        value = newValue;
	        state = 'fulfilled';
	        setTimeout(function () {
	            deferreds.forEach(function (deferred) {
	                deferred(value);
	            });
	        }, 0);
	    }
	
	    fn(resolve);
	}
	
	function getUserId() {
	    return new Promise(function (resolve) {
	        resolve(123);
	    });
	}
	
	getUserId().then(function (id) {
        console.log('do sth with', id);
    });
 
缺点：
then太多，代码分散

	new Promise(function(resolve. reject){
		doSomething1();// 获取品牌列表
		resolve();
	}).then(function(resolve. reject){
		doSomething2();// 根据品牌列表获取型号列表
		resolve();
	}).then(function(resolve. reject){
		doSomething3();// 根据型号列表获取颜色列表
		resolve();
	})

####promise通常用法

	apiGet(url, data) {
      return new Promise((resolve, reject) => {
        axios.get(url, data).then((response) => {
          resolve(response.data)
        }, (response) => {
          reject(response)
          _g.closeGlobalLoading()
          bus.$message({
            message: '请求超时，请检查网络',
            type: 'warning'
          })
        })
      })
    }
    
    
    this.apiGet('admin/groups').then((res) => {
       this.handelResponse(res, (data) => {
         this.groupOptions = data
       })
     })

###Generator函数
函数暂停执行的一种方法，es6语法，特点：
1.函数名称前有＊
2.需要暂停的地方有yield关键字
3.函数执行后返回的是遍历器iterator，不是执行结果，看成指针
	
	function* gen(x){
	  var y = yield x + 2;
	  return y;
	}
	
	var g = gen(1);
	g.next() // { value: 3, done: false }
	g.next(2) // { value: 2, done: true } 

	
####genarator和promise结合

  	var fetch = doAjax(url){
		var data = {}
		return new Promise(function(resolve, reject){
			$.ajax({
				url: url,
				data: data,
				success: function(ret){
					resolve(ret.data)
				},
				error: function(err){
					reject(err)
				}
			})
		})
	};
	
	function* gen(url1, url2){
		var url = 'https://api.github.com/users/github'
		var result1 = yield fetch(url1)
		var result2 = yield fetch(result1)
	
		var result3 = result1 + result2
		console.log(result3)
	}
	/**begin**/
	var _g = gen('/index.php/getList1', '/index.php/getList1');
	// 获取url1的返回值
	_g.next().value.then(function(result1){
		// 把url1的返回值作为输入，返回值赋值给result2
		_g.next(result1).value.then(function(result2){
			_g.next(result2);
		})
	})	
	/**end**/
	
这样写的好处是，当存在多个异步调用有依赖关系时，关键逻辑代码组合在一起可读性更强，只不过generator需要手动一步一步的往前执行，所以衍生出async/await
	
####async/await和promise结合
async/await和generator可以看成是一样的，*替换成async，yield替换成await。只不过，不需要我们写上面那一段代码，因为async/await已经帮我们处理了，我们只需要在await后面的那个方法返回promise对象就行了。
	
### 参考文档
[深入理解Promise](http://www.jianshu.com/p/f8b052c71550)

[Javascript 中的神器——Promise](http://www.jianshu.com/p/063f7e490e9a)

[Promise, generator, async與ES6](http://huli.logdown.com/posts/292655-javascript-promise-generator-async-es6)

[Generator 函数的含义与用法](http://www.ruanyifeng.com/blog/2015/04/generator.html)

[async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)

