webpack的产生原因：
	使用传统的打包方式导致客户端的代码体积过大
	
	1.script:
		全局对象容易冲突
		存在加载顺序问题
		开发者必须处理模块依赖的问题
	2.commjs引入方式（同步）
		阻塞式调用
		不能的一个模块并行加载
	3.AMD异步加载
		代码冗余
		
	4.es6新添加了模块系统
		本地浏览器支持新语法比较浪费时间

	5.关于传输
		采用require的方法一次引入一个文件比较浪费网络负载
		一次请求所有模块容易引入不需要的模块
	6.编译模块的时候找到模块之间的依赖，但是有的开发者的依赖模块名称是动态计算的
	
webpack存在的意义就是找到模块的依赖，并生成静态资源来减轻客户端的负担。

webpack的独特之处：
	1.代码分隔
		webpack
	2.loaders
		webpack仅仅能处理本地静态js文件，loaders是用来把其它类型的资源文件转化成webpack可以处理的 方式
		
es6语法引入
	1.webpack1.0不支持es6语法
	2.es6不支持动态引入，即，不能通过js代码逻辑判断是否需要引入

疑问：
	
1.webpack分离点？？split point	
2.chunk entry chunk的runtime指什么

代码分离的方法：
	entry:
		entry定义的入口有多少个就会把代码分隔成多少个chunk
		CommonsChunkPlugin插件可以避免多个chunk同时引入公共的模块
		其它代码分离的插件：
			ExtractTextPlugin,bundle-loader,promise-loader
		
动态引入：
	es6的import可以指定打包的bundle
	Lazy Loading（https://doc.webpack-china.org/guides/lazy-loading）为es6 import动态引入的一个很好范例
	cache（https://doc.webpack-china.org/guides/caching）学习怎么高效分隔代码
	

模块解析resolve
配置模块的路径路径或者别名
alias:import 或者require的别名

	
	