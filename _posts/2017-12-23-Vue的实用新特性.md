# Vue的实用新特性


### 你可能不知道的v-bind

特性：v-bind 不指定子组件中属性名称，传递整个对象的所有属性

代码文件：
> demo2

代码示例：

	<son v-bind:name="bindObj.name" v-bind:sex="bindObj.sex" v-bind:height="bindObj.height"></son>
	<!--等于-->
    <son v-bind="bindObj"></son>

适用场景：

* 父组件的某个对象所有属性（或者大部分）需要绑定到子组件上
* 绑定多个常量到子组件上，直接v-bind="{showSearch: true, showPage: false}"

优点：

* 子组件不需要再通过parentKey.key这样引用
* 父子组件的属性名称一致

缺点：

* 需要在子组件props中一个个指定对象中对应的属性名称做为子组件的顶级属性 
* 子属性如果不是对象类型的情况下，子组件中的修改不会同步到父组件

### provide / inject 属性注入（2.2.0）

特性：

* 一个祖先组件向其所有子孙后代注入一个依赖（属性），不论组件层次有多深
* 如果该依赖是个对象的话，子组件的修改会同步到其它所有被注入该依赖的组件（不推荐）
* provide组件内无法获取

代码文件：
> demo3
	
适用场景：

* 子组件都要用到的变量，如：传递接口请求id，如：详情页面，子组件获取数据需要数据id

### inheritAttr 属性继承-$attrs (2.4.0)

特性：

* 绑定到子组件的属性，子组件在没有在props中声明的情况下可以通过$attrs访问
* 通过设置inheritAttrs的值防止被绑定到子组件根节点做为普通html属性

代码文件：
> demo4

适用场景：

* 想把绑定的属性传给子组件的子组件，不需要在中间层组件重复定义属性
* 如：可用条件组件
	Common/business/conditionConfig/condition.vue
	Common/business/conditionConfig/conditionDialog.vue
	
优点：

* 避免中间层组件重复定义
* 组件层级之间保持属性名称一致便于理解和调试


#### $slots 插槽访问

特性：

* render创造的子组件不会主动把插槽渲染出来
* vm.$slots.slotName 可以获取组件实例中的插槽DOM节点$
* vm.$slots.default 获取所有未声明名称的插槽

代码文件:

优点：

* 可以更灵活的使用 render定义子组件

适用场景：

* render函数创建子组件

### slot-scope (2.1.0, 2.5.0版本之前该属性必须定义在template标签上)

特点：

* 父组件在模版中也可以使用子组件元素上绑定的属性（包括v-bind绑定的属性）
* 不同插槽可以根据名称分别使用slot-scope
* 插槽上绑定的事件回调可以引用子组件传递的数据
* 支持解构使用

代码文件：
> demo6

适用场景：

* 自定义子组件的部分内容（如：el-table组件）
* 通过父组件对子组件的数据操作（如：编辑组件）

### $scopedSlots （作用类似$slot， 功能和使用场景同$slot）
代码文件：
> demo7

### 你可能不太清楚的scoped css

代码文件：

> demo8

scoped作用域：

* 作用域属于当前组件的dom
* 不影响子组件内的样式
* 不影响v-html渲染的内容
* 影响子组件的根元素（想象一下，这种特性在树形组件中的好处）

原理:

为scope中的css添加data-v开头的属性以提高css的优先级


如何渗透子组件以及v-html：

	  /*from*/
	  .son-wrap .header {
	    color: yellow;
	  }
	  /*to*/
	  .son-wrap >>> .header {
	    color: yellow;
	  }

### css Module－－scope css替代方案 （vue-loader ^9.8.0）

代码文件：

> demo9
简介:

* css-loader提供的功能
* 需要在config.js中开启模块化css功能

特点：

* css模块化
* 只有全局和局部(以组件为单位)两个概念
* 默认为局部css
* .vue文件中模块化的style中可以定义全局的css
* 支持compose（css合并）
* 全局样式的使用方式：
	1.global.css不使用global修饰符，使用的时候import对象
	2.global.css使用global修饰符，子组件dom中直接用对应的原始css

全局和局部的定义方式：

	:global(.header) {
	  text-align: center;
	  color: green;
	}
	
	:local(.footer) {
	  text-align: center;
	  height: 30px;
	  color: #ffffff;
	  background-color: #000000;
	}

.vue文件中的css模块化：

	<style module>
	  .header {
	    /*text-align: center;*/
	    color: red;
	    /*composes: right from '../css/global.css';*/
	    composes: right from '../css/testModule.css';
	  }
	  .footer {
	    text-align: center;
	    height: 30px;
	    color: white;
	    background-color: #dddddd;
	  }
	</style>

原理：

> css-loader去完成 css模块化编译
> 
> .vue文件中的css模块化通过vue-loader中的cssModule设置来实现
> 
> 编译时将类替换为编译后的类，且替换DOM中的对应类
> 
> 编译选择器的id要使用hash才能发挥作用


详情请看：
[vue-loader css modules](https://vue-loader.vuejs.org/zh-cn/features/css-modules.html)

优点：

* 比scoped功能更强大
* 不仅针对vue，还能用于react，angular

缺点：

* 不能渗透到子组件（虽然这种场景不是很常见，一定程度上可以通过全局样式解决）

### 良好的vue使用习惯

1.mixins中的属性以﹩_ 为前缀，并带上命名空间
> 便于和组件自身的方法区分开，增强可读性和可维护性
> 
> 命名空间便于和其它混合对象区分开

代码示例：

	var requestModel = {
	  // ...
	  methods: {
	    ﹩_requestModel_update: function () {
	      // ...
	    }
	  }
	}
	
	

2.单文件组件顶级标签顺序\<script>,\<template> 和 \<style> 标签的顺序保持一致，\<style> 要放在最后，因为style标签总是最次要的
> 可读性
> 
> 如何做一个有修养的人

代码示例：

	<template>...</template>
	<script>/* ... */</script>
	<style>/* ... */</style>

3.其它

	1.实例对象属性顺序，如components，mounted，mixins 
	2.标签使用顺序，如v-for，v-if, v-show, ref
	3.dom 中的组件标签使用kebab-case
